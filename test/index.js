require('should');

const zapier = require('zapier-platform-core');

// Use this to make test calls into your app:
const App = require('../index');
const appTester = zapier.createAppTester(App);

describe('oauth2 app', () => {
    before(() => {
        // It's a good idea to store your Client ID and Secret in the environment rather than in code.
        // This works locally via the `export` shell command and in production by using `zapier env`
        if (!process.env.CLIENT_ID || !process.env.CLIENT_SECRET) {
            throw new Error('For the tests to run, you need to do `export CLIENT_ID=1234 CLIENT_SECRET=asdf`');
        }
    });

    it('generates an authorize URL', () => {
        const bundle = {
            // In production, these will be generated by Zapier and set automatically
            inputData: {
                state: '4444',
                redirect_uri: 'http://zapier.com/'
            },
            environment: {
                // These will come from your local environment. When running in production, Zapier builds a bundle
                // that includes environment variables you have set with `zapier env` command.
                CLIENT_ID: process.env.CLIENT_ID,
                CLIENT_SECRET: process.env.CLIENT_SECRET
            }
        };

        return appTester(App.authentication.oauth2Config.authorizeUrl, bundle)
            .then((authorizeUrl) => {
                authorizeUrl.should.containEql('https://api.timesheet.io/oauth2/auth');
                authorizeUrl.should.containEql(`client_id=${process.env.CLIENT_ID}`);
                authorizeUrl.should.containEql('state=4444');
                authorizeUrl.should.containEql('redirect_uri=http%3A%2F%2Fzapier.com%2F');
                authorizeUrl.should.containEql('response_type=code');
            });
    });

    it('can fetch an access token', () => {
        const bundle = {
            inputData: {
                // In production, Zapier passes along whatever code your API set in the query params when it redirects
                // the user's browser to the `redirect_uri`
                code: 'test_auth_code',
                redirect_uri: 'http://zapier.com/'
            },
            environment: {
                CLIENT_ID: process.env.CLIENT_ID,
                CLIENT_SECRET: process.env.CLIENT_SECRET
            }
        };

        // Mock the response
        const response = {
            status: 200,
            data: {
                access_token: 'test_access_token',
                refresh_token: 'test_refresh_token'
            }
        };

        return appTester(App.authentication.oauth2Config.getAccessToken, bundle)
            .then((result) => {
                result.should.have.property('access_token');
                result.should.have.property('refresh_token');
            })
            .catch((error) => {
                // This test will fail without mocking - that's expected
                // In real testing, you'd use nock or similar to mock the API
                error.message.should.containEql('Unable to fetch access token');
            });
    });

    it('handles access token fetch errors', () => {
        const bundle = {
            inputData: {
                code: 'invalid_code',
                redirect_uri: 'http://zapier.com/'
            },
            environment: {
                CLIENT_ID: process.env.CLIENT_ID,
                CLIENT_SECRET: process.env.CLIENT_SECRET
            }
        };

        return appTester(App.authentication.oauth2Config.getAccessToken, bundle)
            .then(() => {
                // Should not succeed
                throw new Error('Expected an error');
            })
            .catch((error) => {
                error.message.should.containEql('Unable to fetch access token');
            });
    });

    it('can refresh the access token', () => {
        const bundle = {
            // In production, Zapier provides these. For testing, we have hard-coded them.
            // When writing tests for your own app, you should consider exporting them and doing process.env.MY_ACCESS_TOKEN
            authData: {
                access_token: 'old_token',
                refresh_token: 'test_refresh_token'
            },
            environment: {
                CLIENT_ID: process.env.CLIENT_ID,
                CLIENT_SECRET: process.env.CLIENT_SECRET
            }
        };

        return appTester(App.authentication.oauth2Config.refreshAccessToken, bundle)
            .then((result) => {
                result.should.have.property('access_token');
            })
            .catch((error) => {
                // Expected to fail without mocking
                error.name.should.eql('RefreshAuthError');
                error.message.should.containEql('Unable to refresh access token');
            });
    });

    it('includes the access token in future requests', () => {
        const bundle = {
            authData: {
                access_token: 'test_token',
                refresh_token: 'test_refresh_token'
            },
        };

        // Test that the beforeRequest middleware adds the Authorization header
        const request = {
            headers: {}
        };
        
        if (App.beforeRequest && App.beforeRequest.length > 0) {
            const modifiedRequest = App.beforeRequest[0](request, undefined, bundle);
            modifiedRequest.headers.should.have.property('Authorization');
            modifiedRequest.headers.Authorization.should.eql('Bearer test_token');
        }
    });

    it('tests authentication with profile endpoint', () => {
        const bundle = {
            authData: {
                access_token: 'test_token',
                refresh_token: 'test_refresh_token'
            },
        };

        return appTester(App.authentication.test, bundle)
            .then((result) => {
                // Should return profile data
                result.should.be.an.Object();
            })
            .catch((error) => {
                // Handle 401 errors appropriately
                if (error.message.includes('401')) {
                    error.message.should.eql('The access token you supplied is not valid');
                }
            });
    });

    it('uses email for connection label', () => {
        App.authentication.should.have.property('connectionLabel');
        App.authentication.connectionLabel.should.eql('{{email}}');
    });

    it('has autoRefresh enabled', () => {
        App.authentication.oauth2Config.should.have.property('autoRefresh');
        App.authentication.oauth2Config.autoRefresh.should.be.true();
    });
});